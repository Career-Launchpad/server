"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.loadPolicy = void 0;

var _fsExtra = require("fs-extra");

var _yamljs = _interopRequireDefault(require("yamljs"));

var _path = _interopRequireDefault(require("path"));

var _lodash = require("lodash");

var _chalk = _interopRequireDefault(require("chalk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// NOTE: not using path.join because it strips off the leading
var loadPolicy = function loadPolicy(policyPath, safeguardName) {
  return require(`${policyPath || `./policies`}/${safeguardName}`);
};

exports.loadPolicy = loadPolicy;

function runPolicies(_x) {
  return _runPolicies.apply(this, arguments);
}

function _runPolicies() {
  _runPolicies = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(ctx) {
    var basePath, location, localPoliciesPath, localPolicies, policyConfigs, policies, service, artifactsPath, artifacts, jsonYamlArtifacts, runningPolicies, markedPolicies, failed, warned, passed, summary, details;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            basePath = ctx.sls.config.servicePath;
            location = (0, _lodash.get)(ctx.sls.service, 'custom.safeguards.location', '.');
            localPoliciesPath = _path.default.relative(__dirname, _path.default.resolve(basePath, location));

            if (!localPoliciesPath.startsWith('.')) {
              localPoliciesPath = `.${_path.default.sep}${localPoliciesPath}`;
            } // using || [] instead of _.get's default bc if it's falsey we want it to be []


            localPolicies = (0, _lodash.get)(ctx.sls.service, 'custom.safeguards.policies', []).map(function (policy) {
              var safeguardName = policy;
              var safeguardConfig = {};

              if (policy instanceof Object) {
                var policyObjKeys = Object.keys(policy);

                if (policyObjKeys.length !== 1) {
                  throw new Error('Safeguards requires that each item in the policies list be either a string indicating a policy name, or else an object with a single key specifying the policy name with the policy options. One or more items were objects containing multiple keys. Correct these entries and try again.');
                }

                safeguardName = policyObjKeys[0];
                safeguardConfig = policy[safeguardName] || {};
              }

              return {
                safeguardName,
                safeguardConfig,
                policyPath: localPoliciesPath,
                enforcementLevel: 'error',
                title: `Local policy: ${safeguardName}`
              };
            });
            policyConfigs = [].concat(_toConsumableArray(localPolicies), _toConsumableArray(ctx.safeguards));

            if (!(policyConfigs.length === 0)) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt("return");

          case 8:
            ctx.sls.cli.log(`Safeguards Processing...`, `Serverless Enterprise`);
            policies = policyConfigs.map(function (policy) {
              return _objectSpread({}, policy, {
                function: loadPolicy(policy.policyPath, policy.safeguardName)
              });
            });
            service = {
              compiled: {},
              declaration: (0, _lodash.cloneDeep)((0, _lodash.omit)(ctx.sls.service, ['serverless'])),
              provider: ctx.provider,
              frameworkVersion: ctx.sls.version
            };
            artifactsPath = _path.default.join(basePath, '.serverless');
            _context3.next = 14;
            return (0, _fsExtra.readdir)(artifactsPath);

          case 14:
            artifacts = _context3.sent;
            _context3.next = 17;
            return Promise.all(artifacts.filter(function (filename) {
              return filename.match(/\.(json|yml|yaml)$/i);
            }).map(
            /*#__PURE__*/
            function () {
              var _ref = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee(filename) {
                var content;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return (0, _fsExtra.readFile)(_path.default.join(artifactsPath, filename));

                      case 2:
                        content = _context.sent;
                        _context.prev = 3;

                        if (!filename.match(/\.json$/i)) {
                          _context.next = 6;
                          break;
                        }

                        return _context.abrupt("return", [filename, JSON.parse(content)]);

                      case 6:
                        return _context.abrupt("return", [filename, _yamljs.default.parse(content)]);

                      case 9:
                        _context.prev = 9;
                        _context.t0 = _context["catch"](3);
                        ctx.sls.cli.log(`(Safeguards) Failed to parse file ${filename} in the artifacts directory.`, `Serverless Enterprise`);
                        throw _context.t0;

                      case 13:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[3, 9]]);
              }));

              return function (_x2) {
                return _ref.apply(this, arguments);
              };
            }()));

          case 17:
            jsonYamlArtifacts = _context3.sent;
            ctx.sls.cli.log(`Safeguards Results:

   Summary --------------------------------------------------
`, `Serverless Enterprise`);
            service.compiled = (0, _lodash.fromPairs)(jsonYamlArtifacts);
            runningPolicies = policies.map(
            /*#__PURE__*/
            function () {
              var _ref2 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee2(policy) {
                var result, approve, fail, policyHandle;
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        process.stdout.write(`  running - ${policy.title}`);
                        result = {
                          approved: false,
                          failed: false,
                          policy
                        };

                        approve = function approve() {
                          result.approved = true;
                          process.stdout.write(`\r   ${_chalk.default.green('passed')} - ${policy.title}\n`);
                        };

                        fail = function fail(message) {
                          if (result.failed) {
                            result.message += ` ${message}`;
                          } else {
                            var errorWord = policy.enforcementLevel === 'error' ? 'failed' : 'warned';
                            var color = policy.enforcementLevel === 'error' ? _chalk.default.red : _chalk.default.keyword('orange');
                            process.stdout.write(`\r   ${color(errorWord)} - ${policy.title}\n`);
                            result.failed = true;
                            result.message = message;
                          }
                        };

                        policyHandle = {
                          approve,
                          fail
                        };
                        _context2.next = 7;
                        return policy.function(policyHandle, service, policy.safeguardConfig);

                      case 7:
                        if (!result.approved && !result.failed) {
                          ctx.sls.cli.log(`Safeguard Policy "${policy.title}" finished running, but did not explicitly approve the deployment. This is likely a problem in the policy itself. If this problem persists, contact the policy author.`, `Serverless Enterprise`);
                        }

                        return _context2.abrupt("return", result);

                      case 9:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x3) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context3.next = 23;
            return Promise.all(runningPolicies);

          case 23:
            ctx.state.safeguardsResults = _context3.sent;
            markedPolicies = ctx.state.safeguardsResults.filter(function (res) {
              return !res.approved && res.failed;
            });
            failed = markedPolicies.filter(function (res) {
              return res.policy.enforcementLevel === 'error';
            }).length;
            warned = markedPolicies.filter(function (res) {
              return res.policy.enforcementLevel !== 'error';
            }).length;
            passed = ctx.state.safeguardsResults.filter(function (res) {
              return res.approved && !res.failed;
            }).length;
            summary = `Safeguards Summary: ${_chalk.default.green(`${passed} passed`)}, ${_chalk.default.keyword('orange')(`${warned} warnings`)}, ${_chalk.default.red(`${failed} errors`)}`;

            if (!(markedPolicies.length !== 0)) {
              _context3.next = 35;
              break;
            }

            details = `\n   ${_chalk.default.yellow('Details --------------------------------------------------')}\n\n` + markedPolicies.map(function (res, i) {
              return `   ${i + 1}) ${!res.failed ? 'Finished inconclusively. Deployment halted.' : res.policy.enforcementLevel == 'error' ? _chalk.default.red(`Failed - ${res.message}`) : _chalk.default.keyword('orange')(`Warned - ${res.message}`)}
      ${_chalk.default.grey(`details: ${res.policy.function.docs}`)}
      ${res.policy.description}`;
            }).join('\n\n\n');
            process.stdout.write(`${details}\n\n`);

            if (markedPolicies.every(function (res) {
              return res.approved || res.policy.enforcementLevel === 'warning';
            })) {
              _context3.next = 35;
              break;
            }

            ctx.sls.cli.log(summary, `\nServerless Enterprise`);
            throw new Error('Deployment blocked by Serverless Enterprise Safeguards');

          case 35:
            ctx.sls.cli.log(summary, `\nServerless Enterprise`);

          case 36:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _runPolicies.apply(this, arguments);
}

var _default = runPolicies;
exports.default = _default;
//# sourceMappingURL=index.js.map