{"version":3,"sources":["../../../../src/lib/safeguards/policies/allowed-function-names.js"],"names":["vm","require","entries","fromPairs","templateStringToRegExp","pattern","context","runInNewContext","module","exports","allowedFunctionNamesPolicy","policy","service","options","failed","functions","declaration","naming","provider","Resources","compiled","logicalFuncNamesToConfigFuncName","Object","keys","map","funcName","getLambdaLogicalId","Properties","Type","templateContext","SERVICE","serviceObject","name","STAGE","getStage","FUNCTION","regexp","FunctionName","match","fail","approve","docs"],"mappings":";;;;;;;;;;AAAA,IAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;eAC+BA,OAAO,CAAC,QAAD,C;IAA9BC,O,YAAAA,O;IAASC,S,YAAAA,S;AAEjB;;;;;;;AAKA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,OAAD,EAAUC,OAAV;AAAA,SAC7BN,EAAE,CAACO,eAAH,CAAoB,iBAAgBF,OAAQ,MAA5C,EAAmDC,OAAnD,CAD6B;AAAA,CAA/B;;AAGAE,MAAM,CAACC,OAAP,GAAiB,SAASC,0BAAT,CAAoCC,MAApC,EAA4CC,OAA5C,EAAqDC,OAArD,EAA8D;AAC7E,MAAIC,MAAM,GAAG,KAAb;AAD6E,MAG5DC,SAH4D,GAQzEH,OARyE,CAG3EI,WAH2E,CAG5DD,SAH4D;AAAA,MAI/DE,MAJ+D,GAQzEL,OARyE,CAI3EM,QAJ2E,CAI/DD,MAJ+D;AAAA,MAM1BE,SAN0B,GAQzEP,OARyE,CAK3EQ,QAL2E,CAMzE,2CANyE,EAM1BD,SAN0B;AAS7E,MAAME,gCAAgC,GAAGlB,SAAS,CAChDmB,MAAM,CAACC,IAAP,CAAYR,SAAS,IAAI,EAAzB,EAA6BS,GAA7B,CAAiC,UAACC,QAAD;AAAA,WAAc,CAACR,MAAM,CAACS,kBAAP,CAA0BD,QAA1B,CAAD,EAAsCA,QAAtC,CAAd;AAAA,GAAjC,CADgD,CAAlD;AAT6E;AAAA;AAAA;;AAAA;AAa7E,yBAA+CvB,OAAO,CAACiB,SAAD,CAAtD,8HAAmE;AAAA;AAAA,UAAvDM,QAAuD;AAAA;AAAA,UAA3CE,UAA2C,gBAA3CA,UAA2C;AAAA,UAA/BC,IAA+B,gBAA/BA,IAA+B;;AACjE,UAAIA,IAAI,KAAK,uBAAb,EAAsC;AACpC;AACD;;AACD,UAAMC,eAAe,GAAG;AACtBC,QAAAA,OAAO,EAAElB,OAAO,CAACI,WAAR,CAAoBe,aAApB,CAAkCC,IADrB;AAEtBC,QAAAA,KAAK,EAAErB,OAAO,CAACM,QAAR,CAAiBgB,QAAjB,EAFe;AAGtBC,QAAAA,QAAQ,EAAEd,gCAAgC,CAACI,QAAD;AAHpB,OAAxB;AAKA,UAAMW,MAAM,GAAGhC,sBAAsB,CAACS,OAAD,EAAUgB,eAAV,CAArC;;AACA,UAAI,CAACF,UAAU,CAACU,YAAX,CAAwBC,KAAxB,CAA8BF,MAA9B,CAAL,EAA4C;AAC1CtB,QAAAA,MAAM,GAAG,IAAT;AACAH,QAAAA,MAAM,CAAC4B,IAAP,CACG,aAAYlB,gCAAgC,CAACI,QAAD,CAAW,0BAAyBW,MAAO,GAD1F;AAGD;AACF;AA7B4E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+B7E,MAAI,CAACtB,MAAL,EAAa;AACXH,IAAAA,MAAM,CAAC6B,OAAP;AACD;AACF,CAlCD;;AAoCAhC,MAAM,CAACC,OAAP,CAAegC,IAAf,GAAsB,sBAAtB","sourcesContent":["const vm = require('vm')\nconst { entries, fromPairs } = require('lodash')\n\n/*\n * Converts a string that looks like a tagged template literal into a RegExp.\n * Uses the vm module to safely eval the string as a tagged template literal.\n * The context parameter is the only thing the evaluated string is given access to.\n */\nconst templateStringToRegExp = (pattern, context) =>\n  vm.runInNewContext(`new RegExp(\\`^${pattern}$\\`)`, context)\n\nmodule.exports = function allowedFunctionNamesPolicy(policy, service, options) {\n  let failed = false\n  const {\n    declaration: { functions },\n    provider: { naming },\n    compiled: {\n      'cloudformation-template-update-stack.json': { Resources }\n    }\n  } = service\n  const logicalFuncNamesToConfigFuncName = fromPairs(\n    Object.keys(functions || {}).map((funcName) => [naming.getLambdaLogicalId(funcName), funcName])\n  )\n\n  for (const [funcName, { Properties, Type }] of entries(Resources)) {\n    if (Type !== 'AWS::Lambda::Function') {\n      continue\n    }\n    const templateContext = {\n      SERVICE: service.declaration.serviceObject.name,\n      STAGE: service.provider.getStage(),\n      FUNCTION: logicalFuncNamesToConfigFuncName[funcName]\n    }\n    const regexp = templateStringToRegExp(options, templateContext)\n    if (!Properties.FunctionName.match(regexp)) {\n      failed = true\n      policy.fail(\n        `Function \"${logicalFuncNamesToConfigFuncName[funcName]}\" doesn't match RegExp ${regexp}.`\n      )\n    }\n  }\n\n  if (!failed) {\n    policy.approve()\n  }\n}\n\nmodule.exports.docs = 'https://git.io/fjfIq'\n"],"file":"allowed-function-names.js"}